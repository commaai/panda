#!/usr/bin/env python3
"""
Incremental Modular Build System for Panda

This demonstrates how to incrementally introduce the modular build system
alongside the existing monolithic approach. This allows for:

1. Gradual migration - convert modules one at a time
2. Validation - compare outputs between old and new systems
3. Risk mitigation - fall back to old system if needed
4. Parallel development - teams can work on different modules

This script builds both the legacy targets and new modular targets
for comparison and validation.
"""

import os
import sys
import opendbc
import subprocess

# Add modules directory to Python path
sys.path.insert(0, Dir('#modules').srcnode().abspath)

from module_registry import module_registry

PREFIX = "arm-none-eabi-"
BUILDER = "DEV"

# Build configuration (copied from original)
common_flags = []
if os.getenv("RELEASE"):
    BUILD_TYPE = "RELEASE"
    cert_fn = os.getenv("CERT")
    assert cert_fn is not None, 'No certificate file specified. Please set CERT env variable'
    assert os.path.exists(cert_fn), 'Certificate file not found. Please specify absolute path'
else:
    BUILD_TYPE = "DEBUG"
    cert_fn = File("./certs/debug").srcnode().relpath
    common_flags += ["-DALLOW_DEBUG"]
    if os.getenv("DEBUG"):
        common_flags += ["-DDEBUG"]

def objcopy(source, target, env, for_signature):
    return '$OBJCOPY -O binary %s %s' % (source[0], target[0])

def get_version(builder, build_type):
    try:
        git = subprocess.check_output(["git", "rev-parse", "--short=8", "HEAD"], encoding='utf8').strip()
    except subprocess.CalledProcessError:
        git = "unknown"
    return f"{builder}-{git}-{build_type}"

def get_key_header(name):
    from Crypto.PublicKey import RSA

    public_fn = File(f'./certs/{name}.pub').srcnode().get_path()
    with open(public_fn) as f:
        rsa = RSA.importKey(f.read())
    assert(rsa.size_in_bits() == 1024)

    rr = pow(2**1024, 2, rsa.n)
    n0inv = 2**32 - pow(rsa.n, -1, 2**32)

    r = [
        f"RSAPublicKey {name}_rsa_key = {{",
        "  .len = 0x20,",
        f"  .n0inv = {n0inv}U,",
        f"  .n = {to_c_uint32(rsa.n)},",
        f"  .rr = {to_c_uint32(rr)},",
        f"  .exponent = {rsa.e},",
        "};",
    ]
    return r

def to_c_uint32(x):
    nums = []
    for _ in range(0x20):
        nums.append(x % (2**32))
        x //= (2**32)
    return "{" + 'U,'.join(map(str, nums)) + "U}"

# =============================================================================
# INCREMENTAL MODULE DEFINITIONS
# =============================================================================

def register_incremental_modules(base_env):
    """Register the modules we've converted to the new system so far."""

    # 1. HAL STM32H7 module (foundation layer - no dependencies)
    print("Loading HAL STM32H7 module...")
    try:
        module_env = base_env.Clone()
        hal_stm32h7_module = SConscript('modules/hal_stm32h7/SConscript',
                                       exports={'env': module_env, 'module_registry': module_registry},
                                       must_exist=True)
        print(f"✓ Loaded HAL STM32H7 module: {hal_stm32h7_module.description}")
    except Exception as e:
        print(f"✗ Failed to load HAL STM32H7 module: {e}")
        print("  Using fallback registration...")
        module_registry.register_module(
            name='hal_stm32h7',
            description='STM32H7 hardware abstraction layer (fallback)',
            sources=['startup_stm32h7x5xx.s'],
            headers=['board.h', 'clock.h', 'peripherals.h'],
            includes=['.', 'inc'],
            dependencies=[],
            directory='board/stm32h7'
        )

    # 2. Drivers Basic module (depends on HAL)
    print("Loading Drivers Basic module...")
    try:
        module_env = base_env.Clone()
        drivers_basic_module = SConscript('modules/drivers_basic/SConscript',
                                         exports={'env': module_env, 'module_registry': module_registry},
                                         must_exist=True)
        print(f"✓ Loaded Drivers Basic module: {drivers_basic_module.description}")
    except Exception as e:
        print(f"✗ Failed to load Drivers Basic module: {e}")
        print("  Using fallback registration...")
        module_registry.register_module(
            name='drivers_basic',
            description='Basic hardware drivers (fallback)',
            sources=[],
            headers=['gpio.h', 'led.h', 'timers.h', 'pwm.h'],
            includes=['.'],
            dependencies=['hal_stm32h7'],
            directory='board/drivers'
        )

    # 3. Drivers Communication module (depends on Drivers Basic)
    print("Loading Drivers Communication module...")
    try:
        module_env = base_env.Clone()
        drivers_comm_module = SConscript('modules/drivers_comm/SConscript',
                                        exports={'env': module_env, 'module_registry': module_registry},
                                        must_exist=True)
        print(f"✓ Loaded Drivers Communication module: {drivers_comm_module.description}")
    except Exception as e:
        print(f"✗ Failed to load Drivers Communication module: {e}")
        print("  Using fallback registration...")
        module_registry.register_module(
            name='drivers_comm',
            description='Communication drivers (fallback)',
            sources=[],
            headers=['uart.h', 'usb.h', 'spi.h'],
            includes=['.'],
            dependencies=['drivers_basic'],
            directory='board/drivers'
        )

    # 4. Crypto module (self-contained, depends on core system concepts)
    print("Loading Crypto module...")
    try:
        module_env = base_env.Clone()
        crypto_module = SConscript('modules/crypto/SConscript',
                                  exports={'env': module_env, 'module_registry': module_registry},
                                  must_exist=True)
        print(f"✓ Loaded Crypto module: {crypto_module.description}")
    except Exception as e:
        print(f"✗ Failed to load Crypto module: {e}")
        print("  Using fallback registration...")
        module_registry.register_module(
            name='crypto',
            description='Cryptographic functions for secure boot and signing (fallback)',
            sources=['rsa.c', 'sha.c'],
            headers=['rsa.h', 'sha.h', 'hash-internal.h'],
            includes=['.'],
            dependencies=[],
            directory='crypto'
        )

    print("Incremental modules registered:")
    for name, module in module_registry.modules.items():
        print(f"  - {name}: {module.description}")

def build_incremental_target(target_name, platform_config, main_source, extra_flags=None):
    """
    Build a target using both legacy and modular approaches for comparison.

    This function:
    1. Builds using the legacy monolithic approach
    2. Builds using the new modular approach (where available)
    3. Compares the results
    """
    print(f"\nBuilding incremental target: {target_name}")
    extra_flags = extra_flags or []

    project_dir = Dir(f'./board/obj/{target_name}_incremental/')

    # Prepare build environment (same as legacy)
    flags = platform_config["FLAGS"] + extra_flags + common_flags + [
        "-Wall", "-Wextra", "-Wstrict-prototypes", "-Werror",
        "-mlittle-endian", "-mthumb", "-nostdlib", "-fno-builtin",
        "-std=gnu11", "-fmax-errors=1",
        f"-T{File(platform_config['LINKER_SCRIPT']).srcnode().relpath}",
        "-fsingle-precision-constant", "-Os", "-g",
    ]

    env = Environment(
        ENV=os.environ,
        CC=PREFIX + 'gcc',
        AS=PREFIX + 'gcc',
        OBJCOPY=PREFIX + 'objcopy',
        OBJDUMP=PREFIX + 'objdump',
        OBJPREFIX=project_dir,
        CFLAGS=flags,
        ASFLAGS=flags,
        LINKFLAGS=flags,
        CPPPATH=[Dir("./"), "./board/stm32h7/inc", opendbc.INCLUDE_PATH],
        ASCOM="$AS $ASFLAGS -o $TARGET -c $SOURCES",
        BUILDERS={'Objcopy': Builder(generator=objcopy, suffix='.bin', src_suffix='.elf')},
        tools=["default", "compilation_db"],
    )

    # Build modular components in dependency order
    modular_objects = []

    # Build modules in dependency order: hal_stm32h7 -> drivers_basic -> drivers_comm -> crypto
    module_build_order = ['hal_stm32h7', 'drivers_basic', 'drivers_comm', 'crypto']

    for module_name in module_build_order:
        if module_name in module_registry.modules:
            print(f"  Using modular {module_name} module for {target_name}")
            module = module_registry.get_module(module_name)

            # Use the pre-built objects from the module if available
            if hasattr(module, 'built_objects') and module.built_objects:
                print(f"    Using {len(module.built_objects)} pre-built {module_name} objects")
                modular_objects.extend(module.built_objects)
            else:
                # Build module objects with proper environment
                print(f"    Building {module_name} module from sources")
                module_env = env.Clone()

                # Add module-specific includes and flags
                module_includes = module_registry.get_all_includes(module_name)
                module_flags = module_registry.get_all_flags(module_name)
                module_env.Append(CPPPATH=module_includes)
                if module_flags:
                    module_env.Append(CFLAGS=module_flags)
                    module_env.Append(ASFLAGS=module_flags)

                # Add module-specific flags for embedded environment
                module_env.Append(CPPDEFINES=[f'{module_name.upper()}_MODULE_BUILD=1'])

                for source in module.sources:
                    source_path = os.path.join(module.directory, source)
                    obj_name = f"{project_dir}/{module_name}_{os.path.basename(source)}"
                    print(f"      Building {source} -> {obj_name}")

                    # Handle assembly and C source files
                    if source.endswith('.s'):
                        obj = module_env.Object(obj_name, source_path)
                    else:
                        obj = module_env.Object(obj_name, source_path)
                    modular_objects.append(obj)
        else:
            print(f"  WARNING: {module_name} module not found, falling back to legacy build")

    # Build bootstub (legacy approach for now, but using modular objects)
    bs_env = env.Clone()
    bs_env.Append(CFLAGS="-DBOOTSTUB", ASFLAGS="-DBOOTSTUB", LINKFLAGS="-DBOOTSTUB")
    bs_elf = bs_env.Program(f"{project_dir}/bootstub.elf",
        modular_objects + [
            # Legacy files not yet modularized
            "./board/bootstub.c",
        ])
    bs_env.Objcopy(f"./board/obj/bootstub.{target_name}_incremental.bin", bs_elf)

    # Build main application (using modular objects)
    main_elf = env.Program(f"{project_dir}/main.elf", [
        main_source
    ] + modular_objects, LINKFLAGS=[f"-Wl,--section-start,.isr_vector={platform_config['APP_START_ADDRESS']}"] + flags)

    main_bin = env.Objcopy(f"{project_dir}/main.bin", main_elf)
    sign_py = File("./crypto/sign.py").srcnode().relpath
    env.Command(f"./board/obj/{target_name}_incremental.bin.signed", main_bin,
                f"SETLEN=1 {sign_py} $SOURCE $TARGET {cert_fn}")

    return env

# =============================================================================
# PLATFORM CONFIGURATION (same as legacy)
# =============================================================================

base_project_h7 = {
    "STARTUP_FILE": "./board/stm32h7/startup_stm32h7x5xx.s",
    "LINKER_SCRIPT": "./board/stm32h7/stm32h7x5_flash.ld",
    "APP_START_ADDRESS": "0x8020000",
    "FLAGS": [
        "-mcpu=cortex-m7", "-mhard-float", "-DSTM32H7", "-DSTM32H725xx",
        "-Iboard/stm32h7/inc", "-mfpu=fpv5-d16",
    ],
}

# =============================================================================
# BUILD EXECUTION
# =============================================================================

# Generate autogenerated files (same as legacy)
with open("board/obj/gitversion.h", "w") as f:
    version = get_version(BUILDER, BUILD_TYPE)
    f.write(f'extern const uint8_t gitversion[{len(version)}];\n')
    f.write(f'const uint8_t gitversion[{len(version)}] = "{version}";\n')

with open("board/obj/version", "w") as f:
    f.write(f'{get_version(BUILDER, BUILD_TYPE)}')

certs = [get_key_header(n) for n in ["debug", "release"]]
with open("board/obj/cert.h", "w") as f:
    for cert in certs:
        f.write("\n".join(cert) + "\n")

# Create base environment for module system
base_env = Environment(
    ENV=os.environ,
    CC=PREFIX + 'gcc',
    AS=PREFIX + 'gcc',
    OBJCOPY=PREFIX + 'objcopy',
    OBJDUMP=PREFIX + 'objdump',
    tools=["default"],
)

# Register modules and build incrementally
register_incremental_modules(base_env)

# Validate module system
try:
    module_registry.validate_all_dependencies()
    module_registry.print_dependency_graph()
except Exception as e:
    print(f"Module validation failed: {e}")
    Exit(1)

# Build incremental targets
print("\n" + "="*60)
print("BUILDING INCREMENTAL TARGETS")
print("="*60)

# Build panda with incremental approach
panda_env = build_incremental_target(
    target_name="panda_h7",
    platform_config=base_project_h7,
    main_source="./board/main.c",
    extra_flags=[]
)

# Build jungle with incremental approach
jungle_flags = ["-DPANDA_JUNGLE"]
if os.getenv("FINAL_PROVISIONING"):
    jungle_flags += ["-DFINAL_PROVISIONING"]

jungle_env = build_incremental_target(
    target_name="panda_jungle_h7",
    platform_config=base_project_h7,
    main_source="./board/jungle/main.c",
    extra_flags=jungle_flags
)

# Print module statistics
stats = module_registry.get_stats()
print("\nMODULE SYSTEM STATISTICS:")
print(f"  Modules registered: {stats['total_modules']}")
print(f"  Total source files: {stats['total_sources']}")
print(f"  Total header files: {stats['total_headers']}")
print(f"  Modules with tests: {stats['modules_with_tests']}")
print(f"  Modules with dependencies: {stats['modules_with_dependencies']}")

print("\nIncremental build targets created:")
print("  - board/obj/panda_h7_incremental.bin.signed")
print("  - board/obj/panda_jungle_h7_incremental.bin.signed")
print("\nCompare these with legacy targets for validation.")

# Include tests if requested
if GetOption('extras'):
    SConscript('tests/libpanda/SConscript')